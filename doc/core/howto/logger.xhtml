<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Logging with twisted.python.logger</title>
  </head>

  <body>
    <h1>Logging with twisted.python.logger</h1>

    <h2>The Basics</h2>

    <p>Logging consists of two main components: applications that emit events, and observers that receive and handle those events. Events are simply dictionaries containing the relevant data to describe something interesting that has occurred.  For example: a web server might emit an event after handling each request that includes the URI of requested resource, the response's status code, a count of bytes transferred, etc.  All of that information might be contained in a pair of objects representing the request and response:</p>

    <pre class="python">
log.info(request=request, response=response)
    </pre>

    <p>Note that many logging systems are about emitting <i>strings</i>. In such systems, you might expect the API to look like this instead:</p>

    <pre class="python">
log.info(
    "{uri}: status={status}, bytes={size}, etc..."
    .format(uri=request.uri, status=response.code, size=response.size)
)
    </pre>

    <p>One disadvantage to this is that a strings meant to be human-readable are not necessarily great for software to handle.  An observer receiving the above event as a string would have to resort to parsing the string to extract the URI, which is often unreliable.  Additionally, any information not encoded into the string is simply unavailable.  If the <code class="python">request</code> and <code class="python">response</code> objects are available to the observer, it would be possible to write an observer that accessed any attributes of those objects.  It would also be a lot easier to write an observer that emitted structured information by serializing these objects into a format such as JSON, rows in a database, etc.</p>

    <p>Events-as-string do the advantage that it's obvious what an observer that writes strings (eg. an observer that streams text to a file) would emit here.  Since most people are used to server logs that are human-readonable, this is a reasonable thing to expect. We can solve this more flexibly by providing an optional format string in events that can be used for this purpose:</p>

    <pre class="python">
log.info(
    "{request.uri}: status={response.status}, bytes={response.size}, etc...",
    request=request, response=response
)
    </pre>

    <p>Now a text-based observer can use format the text in a prescribed way, and an observer that wants to handle these events specially can do so.</p>


    <h2>Usage for emitting applications</h2>

    <p>The first thing that an application that emits logging events need to do is to instantiate a <code class="API" base="twisted.python.logger">Logger</code> object, which provides the API to emit events.  A <code class="API" base="twisted.python.logger">Logger</code> is often created globally for each module:</p>

    <pre class="python">
from twisted.python.logger import Logger
log = Logger()

def handleData(data):
    log.debug("Got data: {data!r}.", data=data)
    </pre>

    <p>A <code class="API" base="twisted.python.logger">Logger</code> can also be assocaited with a class:</p>

    <pre class="python">
from twisted.python.logger import Logger

class Foo(object):
    log = Logger()

    def oops(self, data):
        self.log.error("Oops! Invalid data from server: {data!r}",
                       data=data)
    </pre>

    <p>All <code class="API" base="twisted.python.logger">Logger</code>s have a namespace, which can be used to categorize events. Namespaces may be specified by passing in a <code class="python">namespace</code> argument to <code class="API" base="twisted.python.logger">Logger</code>'s initializer, but if none is given, the logger will derive its own namespace by using the module name of the callable that instantiated it, or, in the case of a class, by using the fully qualified name of the class.</p>

    <p>In the first example above, the namespace would be <code class="python">some.module</code>, and in the second example, it would be <code class="python">some.module.Foo</code>.</p>


    <h2>Usage for observers</h2>

    <p>...</p>

  </body>
</html>
