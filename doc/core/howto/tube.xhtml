<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>An Introduction to Tubes</title>
</head>
<body>
<h1>An Introduction to Tubes</h1>

<p>
All programs transform input to output.
In the context of doing some blocking calculation, transforming input to output just looks like this:
</p>

<pre class="python">
def process(input):
    output = something(input)
    return output
</pre>

<p>
However, when doing I/O with Twisted, not every input corresponds to exactly one output, so we can't always write synchronous functions like <code>process</code>.
Sometimes we need to wait for more input before we can generate some output; sometimes one piece of input will generate multiple outputs.
</p>

<p>
For example, let's say you are processing a stream of bytes, containing messages that are delimited by marker, <code>b"\r\n"</code> (as many network protocols are).
If your program receives <code>b"hello, world"</code>, as an input, it should deliver zero outputs, since it hasn't seen a message boundary yet.
If it receives <code>b"hello\r\nworld\r\n"</code>, then it should deliver two outputs, <code>b"hello"</code>, and <code>b"world"</code>.
If your program receives <code>b"hello\r"</code>, and then <em>later</em> receives <code>b"\nworld\r\n"</code>, the <em>second</em> invocation needs to return two outputs.
</p>

<p>
Also, when dealing with streams of data from networks, it's common to want to send data somewhere as well as receiving it from somewhere.
Even if your program is concerned with converting a sequence bytes into a sequence of lines, it needs to be aware of the fact that its output may be full, and unprepared receive any more lines.
For example, the line-splitting code above might be used in a proxy that relays output from a cloud server with a very fast datacenter uplink, to computers on very slow consumer networks.
The cloud server's output will easily outpace a home network's input, which means that if the line parser is going as fast as it can, lines will pile up in outgoing buffers while waiting to be sent out, and consume all of the proxy's memory.
When this happens, the line parsing program needs to tell <em>its</em> input to slow down, by indicating that it should no longer produce bytes, until the program consuming the line parser's output is ready again.
</p>

<p>
The <code>twisted.tubes</code> package contains several interfaces and utilities for dealing with passing inputs to outputs, buffering intermediary data, and dealing with flow-control.
<code>tubes</code> will solve some of the problems above for you automatically, and for those problems you need to solve yourself, it will provide common abstractions that make solving them easier.
</p>

<div class="note">
If you've used Twisted before, you may notice that half of this is exactly what <code class="API" base="twisted.protocols.basic">LineReceiver</code> does, and that there are lots of related classes that can do similar things for other message types.
The other half is handled by <a href="producers.xhtml"><code>IProducer</code> and <code>IConsumer</code></a>.

There are three important distinctions here:
<ol>
    <li>
    <code>twisted.tubes</code> is <em>general purpose</em>.
    Whereas each <code>FooReceiver</code> class receives <code>Foo</code>s in its own way, <code>tubes</code> provides consistent, re-usable abstractions for sending and receiving.
    </li>
    <li>
    <code>twisted.tubes</code> <em>does not require subclassing</em>.
    The fact that different responsibilities live in different objects makes it easier to test and instrument them.
    </li>
    <li>
    <code>twisted.tubes</code> <em>handles flow control automatically</em>.
    The manual flow-control notifications provided by <code>IProducer</code> and <code>IConsumer</code> are still used internnally in <code>tubes</code> to hook up to <code>twisted.internet</code>, but the interfaces defined in <code>tubes</code> itself are considerably more flexible, as they allow you to hook together chains of arbitrary length, as opposed to just get buffer notifications for a single connection.
    </li>
</ol>
</div>

<p>
Before we get into the interesting applications of the API, let's start with the simplest example; the simplest way to process any data is to avoid processing it entirely, to pass input straight on to output.
In a networking context, that means an echo server.
Here's a complete program which uses interfaces defined by <code>twisted.tubes</code> to send its input straight on to its output:
</p>

<pre class="python">
def echoFlow(fount, drain):
    return fount.flowTo(drain)
</pre>

<p>
In the above example, <code>echoFlow</code> takes two things: a <em>fount</em>, or a source of data, and a <em>drain</em>, or a place where data eventually goes.
In the context of using tubes, we call such a function a "flow", because it establishes a flow of data from one place to another.
Most often, the arguments to such a function are the two parts of the same network connection. The fount represents data coming in over the connection, and the drain represents data going back out over that same connection.
</p>

<p>
Let's do exactly that, and get <code>echoFlow</code> called with a real, network-facing <code>fount</code> and <code>drain</code>.
</p>

<a href="listings/tubes/echotube.py" class="py-listing">echotube.py</a>

<p>
This fully-functioning example (just run it with "<code>python echotube.py</code>") implements an echo server.
You can test it out with <code>telnet localhost 4321</code>.
(If you are on Windows, and do not have <code>telnet</code> installed, try running <code>pkgmgr /iu:"TelnetClient"</code> first; after waiting a few moments, <code>telnet</code> should be available.)
</p>

<p>
However, this example still performs no processing of the data that it is receiving.
</p>

<p>
To demonstrate both receiving and processing data, let's write a server that:
<ol>
    <li>accepts an incoming connection</li>
    <li>receives lines from that connection</li>
    <li>interprets those lines as either:
        <ol>
            <li>an integer, expressed as an ASCII decimal number, OR</li>
            <li>a command, which is <code>SUM</code> or <code>PRODUCT</code></li>
        </ol>
    </li>
    <li>executes the SUM and PRODUCT commands by adding or multiplying all of the numbers received since the last command (or the beginning of the connection)</li>
    <li>responds to the SUM and PRODUCT commands by writing the result of the calculation out to the connection.</li>
</ol>
</p>

<p>
In order to implement this program, we will construct a <em>cascade</em> of objects which process the data; or, in the parlance of the <code>tubes</code> package, "<code>Pump</code>s".
Each <code>Pump</code> in the <code>cascade</code> will be responsible for processing part of the data.</p>
<p>First we will create a pump that transforms arbitrary segments of a TCP stream into lines, then from lines into a combination of integers and callables (functions that perform the work of the <code>SUM</code> and <code>PRODUCT commands</code>), then from integers and callables into more integers - sums and products - from those integers into lines, and finally from those lines into CRLF-terminated segments of TCP data that are sent back out over the network.
</p>

<p>
Here's a sketch of the overall structure of such a program:
</p>

<a href="listings/tubes/computube.py" class="py-listing">computube.py</a>

<p>
As with <code>echoFlow</code>, <code>mathFlow</code> takes a fount and a drain.  
Rather than connecting them directly, it puts an object between them to process the data.
So what is <code>dataProcessor</code> and what does it return?  We need to write it, and it would look something like this:
</p>

<a href="listings/tubes/dataproc.py" class="py-listing">computube2.py</a>
<p>

</p>

<p>
To complete the example, we need to implement 3 classes, each of which is a Pump:
<ul>
    <li><code>LinesToIntegersOrCommands</code></li>
    <li><code>CommandsAndIntegersToResultIntegers</code></li>
    <li><code>IntegersToLines</code></li>
</ul>
</p>

<p>
Let's implement them.  First, <code>LinesToIntegersOrCommands</code> receives lines and converts them into either integers, or functions, then delivers them on.
</p>

<a href="listings/tubes/intparse.py" class="py-listing">intparse.py</a>

<p>
Next, <code>CommandsAndIntegersToResultIntegers</code> takes that output 
</p>

<a href="listings/tubes/worker.py" class="py-listing">worker.py</a>

<p>
Next, <code>IntegersToLines</code> converts <code>int</code> objects into lines for output.
</p>

<a href="listings/tubes/output.py" class="py-listing">output.py</a>

<p>
Finally, we can put them all together by importing them in our original program, and hooking it up to a server just like <code>echoFlow</code>.
</p>

<a href="listings/tubes/computube3.py" class="py-listing">computube3.py</a>

<p>
A more interesting example might demonstrate the use of tubes to send data to another server.
</p>

<a href="listings/tubes/portforward.py" class="py-listing">portforward.py</a>

<p>
For each incoming connection on port <code>6543</code>, we creating an outgoing connection to the echo server in our previous example.
When we have successfully connected to the echo server we connect our incoming <code>listeningFount</code> to our outgoing <code>connectingDrain</code> and our <code>connectingFount</code> to our <code>listeningDrain</code>.
This forwards all bytes from your <code>telnet</code> client to our echo server, and all bytes from our echo server to your client.
</p>

<pre class="python">
def echoFlow(fount, drain):
    return (fount.flowTo(Tube(stringToNetstring()))
                 .flowTo(drain))
</pre>

<p>
<code class="API" base="twisted.tubes.itube.IFount">flowTo</code> can return a <code class="API" base="twisted.tube.itube">IFount</code> so we can chain <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> calls (in other words, call <code>flowTo</code> on the result of <code>flowTo</code>) to construct a "flow".
In this case, <code>.flowTo(Tube(stringToNetstring()))</code> returns a new <code class="API" base="twisted.tubes.itube">IFount</code> whose output will be <a href="http://cr.yp.to/proto/netstrings.txt">netstring</a>s.
<div class="note">
    If you're curious: specifically, <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> takes an <code class="API" base="twisted.tube.itube">IDrain</code>, and returns the result of that <code class="API" base="twisted.tube.itube">IDrain</code>'s <code class="API" base="twisted.tubes.itube.IDrain">flowingFrom</code> method.
    This allows the <code>Tube</code> - which is the <code>IDrain</code> in this scenario, and therefore what knows what the output will be after it's processed it, to affect the return value of the previous <code>IFount</code>'s <code>flowTo</code> method.
</div>
We have now extended our simple <code>echoFlow</code> to add a length prefix to each chunk of its input before echoing it back to your client.
This demonstrates how you can manipulate data as it passes through a flow.
</p>

</body>
</html>
