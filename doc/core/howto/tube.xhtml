<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>An Introduction to Tubes</title>
</head>
<body>
<h1>An Introduction to Tubes</h1>

<p>Tubes are a mechanism for easily dealing with data flowing through your Twisted application.</p>

<p>
A working series of tubes is composed of a few different elements.  First, you have to have a data source; or, in tubes terminology, an <code class="API" base="twisted.tubes.itube">IFount</code>.
Then, you transform the data coming from the <code class="API" base="twisted.tubes.itube">IFount</code> by flowing it through a <code class="API" base="twisted.tubes.tube">Tube</code>, by calling <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> on it.
Each <code class="API" base="twisted.tubes.tube">Tube</code> has a <code class="API" base="twisted.tubes.tube">Pump</code> which deals with processing its input into its output.
A <code class="API" base="twisted.tubes.tube">Tube</code> is itself an <code class="API" base="twisted.tubes.itube">IFount</code>, so you can repeat this process by flowing each <code class="API" base="twisted.tubes.tube">Tube</code> into the next, until you have the desired output type.
Finally, you select an <code class="API" base="twisted.tubes.itube">IDrain</code> to send the outgoing data to, and flow your final <code class="API" base="twisted.tubes.tube">Tube</code> into that <code class="API" base="twisted.tubes.itube">IDrain</code>.
</p>

<p>Let's see a simple example of what that would look like.  Imagine that you have a wire protocol which decodes length-prefixed chunks of base64-encoded data into UTF-8 text, upper-cases that text, and then emits it as output as length-prefixed, (character)-reversed, UTF-8-encoded strings.</p>

<pre class="python">
def funkyConvert(fount, drain):
    return (fount.flowTo(Tube(netstringsToStrings()))
                 .flowTo(Tube(Base64Decode()))
                 .flowTo(Tube(UTF8Decode()))
                 .flowTo(Tube(Uppercase()))
                 .flowTo(Tube(Reverse()))
                 .flowTo(Tube(UTF8Encode()))
                 .flowTo(Tube(stringsToNetstrings()))
                 .flowTo(drain))
</pre>

<p>
In the above example, notice that the initial "fount" and "drain" are provided as inputs (they will be constructed from objects within Twisted) and you instantiate Tube directly.
In typical usage, behavior that you need to provide comes in the form of a custom Pump.
However, the above example is fairly complex, so let's start with something simpler: how would we just pass on the input straight to the output?
</p>
<pre class="python">
def echoTubeFactory(fount, drain):
    return fount.flowTo(drain)
</pre>

<p>
This is pretty simple; however, in order to actually <i>do</i> anything, we need to find a real-life <code>fount</code> and <code>drain</code> to call <code>echoTubeFactory</code>.
</p>

<a href="listings/tubes/echotube.py" class="py-listing">echotube.py</a>

<p>
This fully-functioning example (just run it with "<code>python echotube.py</code>") implements an echo server.
You can test it out with <code>telnet localhost 4321</code> or <code>nc localhost 4321</code>.
(If you are on Windows, and do not have <code>telnet</code> installed, try running <code>pkgmgr /iu:"TelnetClient"</code> first; after waiting a few moments, <code>telnet</code> should be available.)
</p>

<p>
A more interesting example might demonstrate the use of tubes to send data to another server.
</p>

<a href="listings/tubes/portforward.py" class="py-listing">portforward.py</a>

<p>
Here for each incoming connection on port <code>6543</code> we creating an outgoing connection to the echo server in our previous example.
When we have successfully connected to the echo server we connect our incoming <code>listeningFount</code> to our outgoing <code>connectingDrain</code> and our <code>connectingFount</code> to our <code>listeningDrain</code>.
This forwards all bytes from your <code>telnet</code> or <code>nc</code> client to our echo server, and all bytes from our echo server to your client.
</p>

<pre class="python">
def echoTubeFactory(fount, drain):
    return (fount.flowTo(Tube(stringToNetstring()))
                 .flowTo(drain))
</pre>

<p>
Here you see that <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> can return a <code class="API" base="twisted.tube.itube">IFount</code> so you can chain <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> calls to construct a "flow".
In this case, <code>.flowTo(Tube(stringToNetstring()))</code> returns a new <code class="API" base="twisted.tubes.itube">IFount</code> whose output will be <a href="http://cr.yp.to/proto/netstrings.txt">netstring</a>s.
<div class="note">
    If you're curious: specifically, <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> takes an <code class="API" base="twisted.tube.itube">IDrain</code>, and returns the result of that <code class="API" base="twisted.tube.itube">IDrain</code>'s <code class="API" base="twisted.tubes.itube.IDrain">flowingFrom</code> method.
    This allows the <code>Tube</code> - which is the <code>IDrain</code> in this scenario, and therefore what knows what the output will be after it's processed it, to affect the return value of the previous <code>IFount</code>'s <code>flowTo</code> method.
</div>
We have now extended our simple <code>echoTubeFactory</code> to add a length prefix to each chunk of its input before echoing it back to your client.
This demonstrates how you can manipulate data as it passes through a flow.
</p>

</body>
</html>
