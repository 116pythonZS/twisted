<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>An Introduction to Tubes</title>
</head>
<body>
<h1>An Introduction to Tubes</h1>

<p>
Tubes are a mechanism for easily dealing with data flowing through your Twisted application.
</p>

<p>
All programs transform input to output.  In other words, all programs are, at some level, like this:

<pre class="python">
def process(input):
    output = something(input)
    return output
</pre>

However, in the context of a concurrent, event-driven system like Twisted, not every input corresponds to exactly one output, so we can't always write simple functions like this.
Sometimes we need to wait for more input before we can generate some output; sometimes one piece of input will generate multiple outputs.
Within Twisted, the abstraction for receiving, buffering, and processing streams of data is in the <code>twisted.tubes</code> package, and in this document we're going to learn how to use it.
</p>

<p>
Before we get into the interesting applications of the API, let's start with the simplest example; the simplest way to process any data is to avoid processing it entirely, to pass input straight on to output.
In a networking context, that means an echo server.
Here's a complete program which uses interfaces defined by <code>twisted.tubes</code> to send its input straight on to its output:
</p>

<pre class="python">
def echoFlow(fount, drain):
    return fount.flowTo(drain)
</pre>

<p>
In the above example, <code>echoFlow</code> takes two things: a <i>fount</i>, or a source of data, and a <i>drain</i>, or a place where data eventually goes.
In the context of using tubes, we call such a function a "flow", because it establishes a flow of data from one place to another.
Most often, the arguments to such a function are the two parts of the same network connection. The fount represents data coming in over the connection, and the drain represents data going back out over that same connection.
</p>

<p>
Let's do exactly that, and get <code>echoFlow</code> called with a real, network-facing <code>fount</code> and <code>drain</code>.
</p>

<a href="listings/tubes/echotube.py" class="py-listing">echotube.py</a>

<p>
This fully-functioning example (just run it with "<code>python echotube.py</code>") implements an echo server.
You can test it out with <code>telnet localhost 4321</code> or <code>nc localhost 4321</code>.
(If you are on Windows, and do not have <code>telnet</code> installed, try running <code>pkgmgr /iu:"TelnetClient"</code> first; after waiting a few moments, <code>telnet</code> should be available.)
</p>

<p>
However, this example still performs no processing of the data that it is receiving.
</p>

<p>
To demonstrate both receiving and processing data, let's write a server that:
<ol>
    <li>accepts an incoming connection</li>
    <li>receives lines from that connection</li>
    <li>interprets those lines as either:
        <ol>
            <li>an integer, expressed as an ASCII decimal number, OR</li>
            <li>a command, which is <code>SUM</code> or <code>PRODUCT</code></li>
        </ol>
    </li>
    <li>executes the SUM and PRODUCT commands by adding or multiplying all of the numbers received since the last command (or the beginning of the connection)</li>
    <li>responds to the SUM and PRODUCT commands by writing the result of the calculation out to the connection.</li>
</ol>
</p>

<p>
In order to implement this program, we will use a series of <code>Tube</code> objects, each of which will be responsible for transforming the data; first from raw chunks of TCP data to a sequence of lines, then from lines into integers, and commands, then from integers and commands into sums and products (more integers), from those integers into lines, and finally from those lines into chunks of TCP data that are sent back out over the network.
</p>

<p>
Here's a sketch of the overall structure of such a program:
</p>

<a href="listings/tubes/computube.py" class="py-listing">computube.py</a>

<p>
As with <code>echoFlow</code>, <code>mathFlow</code> takes a fount and a drain.  Rather than connecting them directly, it puts several objects between them.
There are two kinds of objects being constructed by this example. One kind is the Tubes themselves, and the other is each Tube's <i>Pump</i>.
An instance of <code>Tube</code> is, itself, both a fount (specifically, an <code class="API" base="twisted.tubes.itube">IFount</code>) and a drain (<code class="API" base="twisted.tubes.itube">IDrain</code>).
However, a Tube is a fairly dumb object: it doesn't know what to do with the data that it receives.
In order to process the data, the Tube relies on its Pump. The data processing (if any) is embedded in the Pump logic. In this example, one pump convert bytes to lines, another converts lines to integers, another pump calculates SUM or PRODUCT, and so on.
</p>

<p>
Several of the classes involved are already within Twisted: Tube, for example, and several of the Pump classes.  Some of the Pumps, however, we will have to implement as part of the example.  So, to flesh out the <code>computube</code> example a little more, here's a version with the existing classes imported:
</p>

<a href="listings/tubes/computube2.py" class="py-listing">computube2.py</a>

<p>
To complete the example, we need to implement 3 classes, each of which is a Pump:
<ul>
    <li><code>LinesToIntegersOrCommands</code></li>
    <li><code>CommandsAndIntegersToResultIntegers</code></li>
    <li><code>IntegersToLines</code></li>
</ul>
</p>

<p>
Let's implement them.  First, <code>LinesToIntegersOrCommands</code> receives lines and converts them into either integers, or functions, then delivers them on.
</p>

<a href="listings/tubes/intparse.py" class="py-listing">intparse.py</a>

<p>
Next, <code>CommandsAndIntegersToResultIntegers</code> takes that output 
</p>

<a href="listings/tubes/worker.py" class="py-listing">worker.py</a>

<p>
Next, <code>IntegersToLines</code> converts <code>int</code> objects into lines for output.
</p>

<a href="listings/tubes/output.py" class="py-listing">output.py</a>

<p>
Finally, we can put them all together by importing them in our original program, and hooking it up to a server just like <code>echoFlow</code>.
</p>

<a href="listings/tubes/computube3.py" class="py-listing">computube3.py</a>

<p>
A more interesting example might demonstrate the use of tubes to send data to another server.
</p>

<a href="listings/tubes/portforward.py" class="py-listing">portforward.py</a>

<p>
For each incoming connection on port <code>6543</code>, we creating an outgoing connection to the echo server in our previous example.
When we have successfully connected to the echo server we connect our incoming <code>listeningFount</code> to our outgoing <code>connectingDrain</code> and our <code>connectingFount</code> to our <code>listeningDrain</code>.
This forwards all bytes from your <code>telnet</code> or <code>nc</code> client to our echo server, and all bytes from our echo server to your client.
</p>

<pre class="python">
def echoFlow(fount, drain):
    return (fount.flowTo(Tube(stringToNetstring()))
                 .flowTo(drain))
</pre>

<p>
<code class="API" base="twisted.tubes.itube.IFount">flowTo</code> can return a <code class="API" base="twisted.tube.itube">IFount</code> so we can chain <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> calls (in other words, call <code>flowTo</code> on the result of <code>flowTo</code>) to construct a "flow".
In this case, <code>.flowTo(Tube(stringToNetstring()))</code> returns a new <code class="API" base="twisted.tubes.itube">IFount</code> whose output will be <a href="http://cr.yp.to/proto/netstrings.txt">netstring</a>s.
<div class="note">
    If you're curious: specifically, <code class="API" base="twisted.tubes.itube.IFount">flowTo</code> takes an <code class="API" base="twisted.tube.itube">IDrain</code>, and returns the result of that <code class="API" base="twisted.tube.itube">IDrain</code>'s <code class="API" base="twisted.tubes.itube.IDrain">flowingFrom</code> method.
    This allows the <code>Tube</code> - which is the <code>IDrain</code> in this scenario, and therefore what knows what the output will be after it's processed it, to affect the return value of the previous <code>IFount</code>'s <code>flowTo</code> method.
</div>
We have now extended our simple <code>echoFlow</code> to add a length prefix to each chunk of its input before echoing it back to your client.
This demonstrates how you can manipulate data as it passes through a flow.
</p>

</body>
</html>
