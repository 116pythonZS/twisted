<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Twisted Mail Tutorial: Building a Simple IMAP Server</title>
</head>

<body>

<h1>Twisted Mail Tutorial: Building a Simple IMAP Server</h1>

<h2>Introduction</h2>

<p>By the end of the this tutorial, you will have a very simple IMAP server
application. This tutorial will show you how to use the <code class="API">
twisted.mail.imap4</code> to create an IMAP server. The <code class="API">
twisted.mail.imap4.IMAP4Server</code> is the <code>Protocol</code>
implementation of IMAP4rev1. The class implements all the IMAP4 commands
specified in <a href="http://tools.ietf.org/html/rfc3501">RFC 3501</a>.
"What am I supposed to do?" You might ask. Well, if you tried to read the RFC
memo, you might notice that it doesn't care about how/where you actually store
the user account information and the implemenatation of mailboxes. That's where
you come into the game!</p>


<h2>The Skeleton of Our Server</h2>

<p>We will build the server application on top of the skeleton laid out in
this section:</p>

<pre class="python">
from twisted.mail import imap4
from twisted.internet import reactor, defer, protocol
from zope.interface import implements
from twisted.cred.portal import IRealm
from twisted.cred.portal import Portal
from twisted.cred.checkers import InMemoryUsernamePasswordDatabaseDontUse


class SimpleMailbox:
    implements(imap4.IMailboxInfo, imap4.IMailbox, imap4.ICloseableMailbox)
    pass


class Account(imap4.MemoryAccount):
    pass


class MailUserRealm(object):
    implements(IRealm)
    pass


class IMAPServerProtocol(imap4.IMAP4Server):
    pass


class IMAPFactory(protocol.Factory):
    pass


if __name__ == "__main__":
    portal = Portal(MailUserRealm())
    checker = InMemoryUsernamePasswordDatabaseDontUse()
    checker.addUser("testuser", "password")
    portal.registerChecker(checker)

    factory = IMAPFactory()
    factory.portal = portal

    reactor.listenTCP(1143, factory)
    print "IMAP Server is Listening on TCP 1143..."
    reactor.run()
</pre>

<p>The <code>pass</code> statements above are place holders where we will
address one by one throughout this tutorial. We will implement a couple of
mailbox and account related <a href="../../../core/howto/components.html">
interfaces</a>. We will also write the <code>protocol</code> and the <code>
factory</code> for the server application.</p>

<p>The server will be listening on TCP port 1143. We created a <code>portal
</code> which will handle the user login process. The <code>checker</code>
is how we store and check the user credential. In this case, everything is
going to be stored in memory. As the name points out, it's not recommended to
be used in the real world. If you want to know about how <code>Twisted</code>
handles authentications, please check <a href="../../../core/howto/cred.html">
this tutorial</a>.</p>

<p>Let's start to fill in the missing pieces.</p>

<h2>The Mailbox</h2>

<p>The first part of the server we will build is the implementation of
<code class="API">imap4.IMailbox</code>, which has methods for managing
messages and getting information about the mailbox. For this tutorial,
we will implement a dead simple mailbox: all messages will be in the memory,
and in a <code>list</code>!</p>

<p>In the following example, we will implement two mailbox related
interfaces. You can implement as many interfaces as you want, just be
logical and make sure you cover all the methods.</p>

<pre class="python">
class SimpleMailbox:
    implements(imap4.IMailbox, imap4.ICloseableMailbox)

    flags = ('\\Seen', '\\Answered', '\\Flagged',
             '\\Deleted', '\\Draft', '\\Recent', 'List')
    messages = []
    mUID = 0 
    rw = 1 
    closed = False

    def __init__(self):
        self.listeners = []
        self.addListener = self.listeners.append
        self.removeListener = self.listeners.remove

    def getFlags(self):
        return self.flags

    def getHierarchicalDelimiter(self):
        return '/'

    def getUIDValidity(self):
        pass

    def getUIDNext(self):
        pass

    def getUID(self, message):
        pass

    def getMessageCount(self):
        return 9

    def getRecentCount(self):
        pass

    def getUnseenCount(self):
        return 4

    def isWriteable(self):
        pass

    def destroy(self):
        pass

    def requestStatus(self, names):
        r = {}
        if 'MESSAGES' in names:
            r['MESSAGES'] = self.getMessageCount()
        if 'UNSEEN' in names:
            r['UNSEEN'] = self.getUnseenCount()
        return defer.succeed(r)

    def addListener(self, listener):
        pass

    def removeListener(self, listener):
        pass

    def addMessage(self, message, flags, date = None):
        pass

    def expunge(self):
        pass

    def fetch(self, messages, uid = False):
        pass

    def store(self, messages, flags, mode, uid):
        pass

    def close(self):
        self.closed = True
</pre>

<p>We put a lot of <code>pass</code> statements in the methods - we only
implemented the methods that were needed in this example. The example
<a href="imapclient.py">client</a> that comes with this tutorial will request
how many messages and unseen messages in the test user's mailbox. We didn't
add any actual messages, so we simple returned some static numbers. When you
design your own mailbox, you might want to implement all the class methods
listed above fully. To know the purposes of those methods, feel free to
consult the API of <code class="API">imap4.IMailbox</code> and<code class="API">
imap4.ICloseableMailbox</code>.</p>

<h2>Account</h2>

<p>Now, let's take a look at the <code>Account</code> class that manages an
user's mailboxes.</p>

<pre class="python">
class Account(imap4.MemoryAccount):
    mailboxFactory = SimpleMailbox

    def __init__(self, name):
        imap4.MemoryAccount.__init__(self, name)
        # let's create a default mailbox for a user
        if 'Index' not in self.mailboxes:
            self.create("Inbox")

    def _emptyMailbox(self, name, id):
        return self.mailboxFactory()
</pre>

<p>The <code>Account</code> class inherits from <code>
imap4.MemoryAccount</code>, which in fact is an implementation of the
<code class="API">twisted.mail.imap4.IAccount</code> interface. The
<code>imap4.MemoryAccount</code> provides methods for selecting, listing,
creating, deleting, renaming and subscribing to mailboxes. All the mailboxes
are simply stored in a <code>list</code>. We overrode the default
<code>__init__</code> method to include a default mailbox <em>Index</em>.</p>

<p>
It's also necessary to implement <code>_emptyMailbox</code> method, otherwise,
you would get an <code>NotImplementedError</code> exception. The
<code>imap4.MemoryAccount.addMailbox</code> method uses <code>_emptyMailbox
</code> to create empty mailboxes. In this example, we return an object of
<code>SimpleMailbox</code> class in <code>_emptyMailbox</code> for the
creation of a new mailbox.</p>

<h2>The Realm</h2>

<p>As I already mentioned, IMAP4 protocol itself doesn't care how you
authenticate a user. You already saw that we use the module
<code class="API">Cred</code> to authenticate our <code>testuser</code>.
It's time to define our realm. There is only method we need to
implement.</p>

<pre class="python">
class MailUserRealm(object):
    implements(IRealm)

    avatarInterfaces = {
        imap4.IAccount: Account,
    }

    def requestAvatar(self, avatarId, mind, *interfaces):
        for requestedInterface in interfaces:
            if self.avatarInterfaces.has_key(requestedInterface):
                # return an instance of the correct class
                avatarClass = self.avatarInterfaces[requestedInterface]
                avatar = avatarClass("testuser")
                # null logout function: take no arguments and do nothing
                logout = lambda: None
                return defer.succeed((requestedInterface, avatar, logout))

        # none of the requested interfaces was supported
        raise KeyError("None of the requested interfaces is supported")
</pre>

<p>We defines a dictionary called <code>avatarInterfaces</code>, which maps
the <code>imap4.IAccount</code> interface to our <code>Account</code> class.
When <code>requestAvatar</code> is called, <code>MailUserRealm</code> tried
to find the correct Account instance for the <code>testuser</code>. The
<code>avatarInterfaces</code> is not necessary, we have it here to ensure it
finds the correct <code>Account</code> instance.</p>

<h2>The IMAP Server Protocol and Factory</h2>

<p>Now, onto the IMAP4 protocol implementation. Twisted already did most
of the job for us, all we have to is to use it! First thing we need to do
is to pass the <code>portal</code> to our class. Second thing we will do
is to add a <code>debug</code> variable so we could see the communication
between the client and the server.</p>


<pre class="python">
class IMAPServerProtocol(imap4.IMAP4Server):
    "Subclass of imap4.IMAP4Server that adds debugging."
    debug = True


    def __init__(self, portal, *args, **kw):
        imap4.IMAP4Server.__init__(self, *args, **kw)
        self.portal = portal
        self.timeoutTest = False


    def lineReceived(self, line):
        if self.debug:
            print "CLIENT:", line
        imap4.IMAP4Server.lineReceived(self, line)


    def sendLine(self, line):
        imap4.IMAP4Server.sendLine(self, line)
        if self.debug:
            print "SERVER:", line
</pre>


<p>The factory class will be really simple too, all we need to do is pass the
<code>portal</code> to the <code>protocol</code>:</p>

<pre class="python">
class IMAPFactory(protocol.Factory):
    protocol = IMAPServerProtocol
    portal = None # placeholder

    def buildProtocol(self, address):
        p = self.protocol(self.portal)
        p.factory = self
        return p
</pre>

<h2>Finally, Let's connect!</h2>

<p>Now, let's see the <a href="imapserver.py">server</a> and
<a href="imapclient.py">client</a> in action! Start the server in a
terminal and the client in another: </p>

<pre class="shell">
$ python imapserver.py
IMAP Server is Listening on TCP 1143...
SERVER: * OK [CAPABILITY IMAP4rev1 IDLE NAMESPACE] Twisted IMAP4rev1 Ready
CLIENT: 0001 LOGIN "testuser" "password"
SERVER: 0001 OK LOGIN succeeded
CLIENT: 0002 LIST "" "*"
SERVER: * LIST (\Seen \Answered \Flagged \Deleted \Draft \Recent List) "/" "INBOX"
SERVER: 0002 OK LIST completed
CLIENT: 0003 STATUS INBOX (MESSAGES UNSEEN)
SERVER: * STATUS INBOX (MESSAGES 9 UNSEEN 4)
SERVER: 0003 OK STATUS complete
CLIENT: 0004 LOGOUT
SERVER: * BYE Nice talking to you
SERVER: 0004 OK LOGOUT successful
</pre>

<pre class="shell">
$ python imapclient.py
IMAP4 Server Hostname: localhost
IMAP4 Server Port (the default is 143): 1143
IMAP4 Username: testuser
IMAP4 Password: 
No secure authentication available. Login insecurely? (y/N) y
1. INBOX
Which mailbox? [1] 1
You have 9 messages (4 unseen)!
</pre>

<p>So, in our client, we login as <code>testuser</code> and ask for a list of
the mailboxes of the user. Then, we select the <em>INBOX</em> and the server
outputs the fake number. The client will terminate itself
after getting the server feedback about the mailbox status.
As for the server, you need to manually shut it down by issuing
<code>^C</code>, otherwise, it will keep listening on port 1143.</p>

<p>I hope you enjoyed the tutorial. By now, you should know the basic about
how to use Twisted to create an IMAP server. I know there are still a <em>lot
</em>to do if you want to develop a fully featured IMAP server, but at least
you know where to start now.</p>
</body>
</html>
