<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Creating and working with a names (DNS) server</title></head>
<body>
<h1>Creating and working with a names (DNS) server</h1>

<p>A Names server can be perform three basic operations:</p>

<ul>
<li>act as a recursive server, forwarding queries to other servers</li>
<li>perform local caching of recursively discovered records</li>
<li>act as the authoritative server for a domain</li>
</ul>

<h2>Creating a non-authoritative server</h2>

<p>
The first two of these are easy, and you can create a server that performs them
with the command <code class="shell">twistd -n dns --recursive --cache</code>.
You may wish to run this as root since it will try to bind to UDP port 53.  Try
performing a lookup with it, <code class="shell">dig twistedmatrix.com
@127.0.0.1</code>.
</p>

<h2>Creating an authoritative server</h2>

<p>To act as the authority for a domain, two things are necessary: the address
of the machine on which the domain name server will run must be registered
as a nameserver for the domain; and the domain name server must be
configured to act as the authority.  The first requirement is beyond the
scope of this howto and will not be covered.
</p>

<p>To configure Names to act as the authority
for <code>example-domain.com</code>, we first create a zone file for
this domain.</p>

<a href="listings/names/example-domain.com" class="py-listing">Zone file</a>

<p>Next, run the command <code class="shell">twistd -n dns --pyzone
example-domain.com</code>.  Now try querying the domain locally (again, with
dig): <code class="shell">dig -t any example-domain.com @127.0.0.1</code>.
</p>

<p>Names can also read a traditional, BIND-syntax zone file.  Specify these
with the <code>--bindzone</code> parameter.  The $GENERATE and $INCLUDE
directives are not yet supported.
</p>


<h2>Creating a custom server</h2>
<p>
  The builtin DNS server plugin is useful,
  but the beauty of Twisted Names is that
  you can build your own custom servers and clients using the names components.
</p>

<p>Lets start by creating a simple DNS server:</p>
<a href="listings/names/simple_server.py" class="py-listing">Simple Server Example</a>

<p>
  In this example, we are passing a single client resolver to the DNSServerFactory
  and we are configuring that client to use the upstream DNS servers
  which are specified in a local resolv.conf file.
</p>

<p>
  Also note that we start the server listening on both UDP and TCP ports.
  This is a standard requirement for DNS servers.
</p>

<p>
  You can test the server using the dig tool. For example:
</p>

<code>
$ dig -p 10053 @127.0.0.1 example.com SOA +short
sns.dns.icann.org. noc.dns.icann.org. 2013102791 7200 3600 1209600 3600
</code>

<p>
  Now suppose we want to create a bespoke DNS server
  which responds to certain hostname queries
  by dynamically calculating the resulting IP address,
  while passing all other queries to another DNS server.
</p>

<p>
  ie hostname queries for names matching the pattern <em>workstation{0-9}+</em>
  will always result in an IP address where the last octet matches the
  workstation number.
</p>

<p>
  We can achieve that by writing a custom resolver
  which we insert before the standard client resolver.
  The custom resolver will be queried first,
  and if it returns a DomainError,
  the DNSServerFactory will then dispatch the query to the standard client.
</p>

<p>Here's the code:</p>
<a href="listings/names/override_server.py" class="py-listing">Override example</a>

<p>
  In fact, the fallback behaviour is handled by ResolverChain.
  ResolverChain is a proxy for other resolvers.
  It takes a list of IResolver providers and queries each one in turn
  until it receives an answer.
  The job of DNSServerFactory is to take a list of authoritative resolvers, caches and client resolvers
  and ensure that they are added to the ResolverChain in the correct order.
</p>

<p>
  Let's use dig to see how this server responds to requests that match the pattern we specified.
</p>

<code>
$ dig -p 10053 @127.0.0.1 workstation1.example.com A +short
172.0.2.1

$ dig -p 10053 @127.0.0.1 workstation100.example.com A +short
172.0.2.100
</code>


<p>
  And if we issue a request that doesn't match the pattern.
</p>

<code>
$ dig -p 10053 @127.0.0.1 foobar.example.com A +short
67.215.65.132
</code>

</body>
</html>
