# -*- test-case-name: twisted.words.test.test_jabberserver -*-
#
# Copyright (c) 2001-2007 Twisted Matrix Laboratories.
# See LICENSE for details.

"""
XMPP Server-to-Server protocol.

This module implements several aspects of XMPP server-to-server communications
as described in XMPP Core (RFC 3920). Refer to that document for the meaning
of the used terminology.
"""

# hashlib is new in Python 2.5, try that first.
try:
    from hashlib import sha256
except ImportError:
    from Crypto.Hash.SHA256 import new as sha256
import hmac

from zope.interface import implements
from twisted.internet import defer, reactor
from twisted.names.srvconnect import SRVConnector
from twisted.words.protocols.jabber import error, ijabber, jid, xmlstream
from twisted.words.xish import domish

NS_DIALBACK = 'jabber:server:dialback'

def generateKey(secret, receivingServer, originatingServer, streamID):
    """
    Generate a dialback key for server-to-server XMPP Streams.

    The dialback key is generated using the algorithm described in
    U{XEP-0185<http://www.xmpp.org/extensions/xep-0185.html>}. The used
    terminology for the parameters is described in RFC-3920.

    @param secret: the shared secret known to the Originating Server and
                   Authoritive Server.
    @type secret: C{str}
    @param receivingServer: the Receiving Server host name.
    @type receivingServer: C{str}
    @param originatingServer: the Originating Server host name.
    @type originatingServer: C{str}
    @param streamID: the Stream ID as generated by the Receiving Server.
    @type streamID: C{str}
    @return: hexadecimal digest of the generated key.
    @type: C{str}
    """

    hashObject = sha256()
    hashObject.update(secret)
    hashedSecret = hashObject.hexdigest()
    message = " ".join([receivingServer, originatingServer, streamID])
    hash = hmac.HMAC(hashedSecret, message, digestmod=sha256)
    return hash.hexdigest()

class XMPPServerConnector(SRVConnector):
    def __init__(self, reactor, domain, factory):
        SRVConnector.__init__(self, reactor, 'xmpp-server', domain, factory)

    def pickServer(self):
        host, port = SRVConnector.pickServer(self)

        if not self.servers and not self.orderedServers:
            # no SRV record, fall back..
            port = 5269

        return host, port

class DialbackFailed(Exception):
    pass

class OriginatingDialbackInitializer(object):
    """
    Server Dialback Initializer for the Orginating Server.
    """

    implements(ijabber.IInitiatingInitializer)

    _deferred = None

    def __init__(self, xs, thisHost, otherHost, secret):
        self.xmlstream = xs
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.secret = secret

    def initialize(self):
        self._deferred = defer.Deferred()
        self.xmlstream.addObserver(xmlstream.STREAM_ERROR_EVENT,
                                   self.onStreamError)
        self.xmlstream.addObserver("/result[@xmlns='%s']" % NS_DIALBACK,
                                   self.onResult)

        key = generateKey(self.secret, self.otherHost,
                          self.thisHost, self.xmlstream.sid)

        result = domish.Element((NS_DIALBACK, 'result'))
        result['from'] = self.thisHost
        result['to'] = self.otherHost
        result.addContent(key)

        self.xmlstream.send(result)

        return self._deferred

    def onResult(self, result):
        self.xmlstream.removeObserver(xmlstream.STREAM_ERROR_EVENT,
                                      self.onStreamError)
        if result['type'] == 'valid':
            self.xmlstream.otherEntity = jid.internJID(self.otherHost)
            self._deferred.callback(None)
        else:
            self._deferred.errback(DialbackFailed())

    def onStreamError(self, failure):
        self.xmlstream.removeObserver("/result[@xmlns='%s']" % NS_DIALBACK,
                                      self.onResult)
        self._deferred.errback(failure)

class ReceivingDialbackInitializer(object):
    """
    Server Dialback Initializer for the Receiving Server.
    """

    implements(ijabber.IInitiatingInitializer)

    _deferred = None

    def __init__(self, xs, thisHost, otherHost, originalStreamID, key):
        self.xmlstream = xs
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.originalStreamID = originalStreamID
        self.key = key

    def initialize(self):
        self._deferred = defer.Deferred()
        self.xmlstream.addObserver(xmlstream.STREAM_ERROR_EVENT,
                                   self.onStreamError)
        self.xmlstream.addObserver("/verify[@xmlns='%s']" % NS_DIALBACK,
                                   self.onVerify)

        verify = domish.Element((NS_DIALBACK, 'verify'))
        verify['from'] = self.thisHost
        verify['to'] = self.otherHost
        verify['id'] = self.originalStreamID
        verify.addContent(self.key)

        self.xmlstream.send(verify)
        return self._deferred

    def onVerify(self, verify):
        self.xmlstream.removeObserver(xmlstream.STREAM_ERROR_EVENT,
                                      self.onStreamError)
        if verify['id'] != self.originalStreamID:
            self.xmlstream.sendStreamError(error.StreamError('invalid-id'))
            self._deferred.errback(DialbackFailed())
        elif verify['to'] != self.thisHost:
            self.xmlstream.sendStreamError(error.StreamError('host-unknown'))
            self._deferred.errback(DialbackFailed())
        elif verify['from'] != self.otherHost:
            self.xmlstream.sendStreamError(error.StreamError('invalid-from'))
            self._deferred.errback(DialbackFailed())
        elif verify['type'] == 'valid':
            self._deferred.callback(None)
        else:
            self._deferred.errback(DialbackFailed())

    def onStreamError(self, failure):
        self.xmlstream.removeObserver("/verify[@xmlns='%s']" % NS_DIALBACK,
                                      self.onVerify)
        self._deferred.errback(failure)

class XMPPServerConnectAuthenticator(xmlstream.ConnectAuthenticator):
    namespace = 'jabber:server'

    def __init__(self, thisHost, otherHost, secret):
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.secret = secret
        xmlstream.ConnectAuthenticator.__init__(self, otherHost)

    def connectionMade(self):
        self.xmlstream.thisEntity = jid.internJID(self.thisHost)
        self.xmlstream.prefixes = {xmlstream.NS_STREAMS: 'stream',
                                   NS_DIALBACK: 'db'}
        xmlstream.ConnectAuthenticator.connectionMade(self)

    def associateWithStream(self, xs):
        xmlstream.ConnectAuthenticator.associateWithStream(self, xs)
        init = OriginatingDialbackInitializer(xs, self.thisHost,
                                              self.otherHost, self.secret)
        xs.initializers = [init]

class XMPPServerVerifyAuthenticator(xmlstream.ConnectAuthenticator):
    namespace = 'jabber:server'

    def __init__(self, thisHost, otherHost, originalStreamID, key):
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.originalStreamID = originalStreamID
        self.key = key
        xmlstream.ConnectAuthenticator.__init__(self, otherHost)

    def connectionMade(self):
        self.xmlstream.thisEntity = jid.internJID(self.thisHost)
        self.xmlstream.prefixes = {xmlstream.NS_STREAMS: 'stream',
                                   NS_DIALBACK: 'db'}
        xmlstream.ConnectAuthenticator.connectionMade(self)

    def associateWithStream(self, xs):
        xmlstream.ConnectAuthenticator.associateWithStream(self, xs)
        init = ReceivingDialbackInitializer(xs, self.thisHost, self.otherHost,
                                            self.originalStreamID, self.key)
        xs.initializers = [init]

class XMPPServerListenAuthenticator(xmlstream.ListenAuthenticator):
    namespace = 'jabber:server'
    connectorClass = XMPPServerConnector

    def __init__(self, domain, secret):
        xmlstream.ListenAuthenticator.__init__(self)
        self.domain = domain
        self.secret = secret

    def streamStarted(self, rootElement):
        xmlstream.ListenAuthenticator.streamStarted(self, rootElement)

        self.xmlstream.namespace = self.namespace
        self.xmlstream.prefixes = {xmlstream.NS_STREAMS: 'stream',
                                   NS_DIALBACK: 'db'}
        self.xmlstream.thisEntity = jid.internJID(self.domain)
        self.xmlstream.sid = 'random' # FIXME

        try:
            if xmlstream.NS_STREAMS != rootElement.uri or \
               self.namespace != rootElement.defaultUri or \
               ('db', NS_DIALBACK) not in rootElement.localPrefixes.iteritems():
                raise error.StreamError('invalid-namespace')

            if rootElement.hasAttribute("to") and \
               rootElement["to"] != self.domain:
                raise error.StreamError('host-unknown')
        except error.StreamError, exc:
            self.xmlstream.sendStreamError(exc)
            return

        self.xmlstream.addObserver("//verify[@xmlns='%s']" % NS_DIALBACK,
                                   self.onVerify)
        self.xmlstream.addObserver("//result[@xmlns='%s']" % NS_DIALBACK,
                                   self.onResult)
        self.xmlstream.sendHeader()

        if self.xmlstream.version >= (1, 0):
            features = domish.Element((xmlstream.NS_STREAMS, 'features'))
            self.xmlstream.send(features)

    def onVerify(self, verify):
        receivingServer = verify.getAttribute('from')
        originatingServer = verify.getAttribute('to')
        streamID = verify.getAttribute('id')
        key = unicode(verify)

        if originatingServer != self.domain:
            self.xmlstream.sendStreamError(error.StreamError('host-unknown'))
            return
        #if receivingServer != ??:
        #    self.xmlstream.sendStreamError(error.StreamError('invalid-from'))
        #    return

        calculatedKey = generateKey(self.secret, receivingServer,
                                    originatingServer, streamID)
        validity = (key == calculatedKey) and 'valid' or 'invalid'

        reply = domish.Element((NS_DIALBACK, 'verify'))
        reply['from'] = originatingServer
        reply['to'] = receivingServer
        reply['id'] = streamID
        reply['type'] = validity
        self.xmlstream.send(reply)
        # self.xmlstream.sendFooter()

    def onResult(self, result):
        def connected(xs):
            self.verifyStream = xs

            from twisted.python import log

            def logDataIn(buf):
                log.msg("RECV!: %r" % buf)

            def logDataOut(buf):
                log.msg("SEND!: %r" % buf)

            xs.rawDataInFn = logDataIn
            xs.rawDataOutFn = logDataOut

        def reply(validity):
            factory.stopTrying()
            self.verifyStream.transport.loseConnection()
            self.verifyStream = None

            reply = domish.Element((NS_DIALBACK, 'result'))
            reply['from'] = result['to']
            reply['to'] = result['from']
            reply['type'] = validity
            self.xmlstream.send(reply)

        def valid(xs):
            reply('valid')
            self.xmlstream.otherEntity = jid.internJID(originatingServer)
            self.xmlstream.dispatch(self.xmlstream,
                                    xmlstream.STREAM_AUTHD_EVENT)

        def invalid(failure):
            reply('invalid')

        originatingServer = result['from']

        authenticator = XMPPServerVerifyAuthenticator(self.domain,
                                                      originatingServer,
                                                      self.xmlstream.sid,
                                                      unicode(result))
        factory = xmlstream.XmlStreamFactory(authenticator)
        factory.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT, connected)
        factory.addBootstrap(xmlstream.STREAM_AUTHD_EVENT, valid)
        factory.addBootstrap(xmlstream.INIT_FAILED_EVENT, invalid)
        connector = self.connectorClass(reactor,
                                        originatingServer,
                                        factory)
        connector.connect()
